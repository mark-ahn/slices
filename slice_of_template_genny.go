// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package slices

type SliceOfInterfaceIterIf interface {
	Range(f func(i int, d interface{}) bool)
	Map(f func(i int, d interface{}) interface{}) SliceOfInterfaceMutIf
}
type SliceOfInterfaceIf interface {
	Get(int) interface{}
	Len() int
}
type SliceOfInterfaceMutIf interface {
	SliceOfInterfaceIf
	Set(int, interface{}) interface{}
}

type SliceOfInterfaceAsIterIf interface {
	AsIter() SliceOfInterfaceIterIf
}

type SliceOfInterfaceI32If interface {
	Get(int32) interface{}
	Len() int32
}
type SliceOfInterfaceI32MutIf interface {
	SliceOfInterfaceI32If
	Set(int32, interface{}) interface{}
}

func SliceOfInterfaceInto(__ SliceOfInterfaceIf) []interface{} {
	switch d := __.(type) {
	case SliceOfInterface:
		return []interface{}(d)
	case *SliceOfInterfaceSt:
		return []interface{}(d.somes)
	case nil:
		return nil
	default:
		res := make([]interface{}, __.Len())
		for i := 0; i < len(res); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type SliceOfInterface []interface{}

func (__ SliceOfInterface) Get(i int) interface{} {
	return __[i]
}
func (__ SliceOfInterface) Set(i int, d interface{}) interface{} {
	old := __[i]
	__[i] = d
	return old
}

func (__ SliceOfInterface) Len() int {
	return len(__)
}

func (__ SliceOfInterface) AsIter() SliceOfInterfaceIterIf {
	return SliceOfInterfaceIter(__)
}

func SliceOfInterfaceI32Into(__ SliceOfInterfaceI32If) []interface{} {
	switch d := __.(type) {
	case SliceOfInterfaceI32:
		return []interface{}(d)
	case *SliceOfInterfaceStI32:
		return []interface{}(d.somes)
	case nil:
		return nil
	default:
		res := make([]interface{}, __.Len())
		for i := int32(0); i < int32(len(res)); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type SliceOfInterfaceI32 []interface{}

func (__ SliceOfInterfaceI32) Get(i int32) interface{} {
	return __[int(i)]
}

func (__ SliceOfInterfaceI32) Set(i int32, d interface{}) interface{} {
	old := __[i]
	__[i] = d
	return old
}

func (__ SliceOfInterfaceI32) Len() int32 {
	return int32(len(__))
}

func (__ SliceOfInterfaceI32) AsIter() SliceOfInterfaceIterIf {
	return SliceOfInterfaceIter(__)
}

type SliceOfInterfaceSt struct {
	somes SliceOfInterface
}

func NewSliceOfInterfaceSt(i int) *SliceOfInterfaceSt {
	return &SliceOfInterfaceSt{somes: SliceOfInterface(make([]interface{}, i))}
}

func (__ *SliceOfInterfaceSt) Get(i int) interface{} {
	return __.somes.Get(i)
}
func (__ *SliceOfInterfaceSt) Set(i int, d interface{}) interface{} {
	return __.somes.Set(i, d)
}

func (__ *SliceOfInterfaceSt) Len() int {
	return __.somes.Len()
}

func (__ *SliceOfInterfaceSt) AsIter() SliceOfInterfaceIterIf {
	return __.somes.AsIter()
}

type SliceOfInterfaceStI32 struct {
	somes SliceOfInterfaceI32
}

func NewSliceOfInterfaceStI32(i int32) *SliceOfInterfaceStI32 {
	return &SliceOfInterfaceStI32{somes: SliceOfInterfaceI32(make([]interface{}, i))}
}

func (__ *SliceOfInterfaceStI32) Get(i int32) interface{} {
	return __.somes.Get(i)
}
func (__ *SliceOfInterfaceStI32) Set(i int32, d interface{}) interface{} {
	return __.somes.Set(i, d)
}

func (__ *SliceOfInterfaceStI32) Len() int32 {
	return __.somes.Len()
}

func (__ *SliceOfInterfaceStI32) AsIter() SliceOfInterfaceIterIf {
	return __.somes.AsIter()
}

type SliceOfInterfaceIter []interface{}

func (__ SliceOfInterfaceIter) Range(f func(i int, d interface{}) bool) {
	for i := range __ {
		if !f(i, __[i]) {
			break
		}
	}
}
func (__ SliceOfInterfaceIter) Map(f func(i int, d interface{}) interface{}) SliceOfInterfaceMutIf {
	rval := make([]interface{}, len(__))
	for i := range __ {
		rval[i] = f(i, __[i])
	}
	return SliceOfInterface(rval)
}
