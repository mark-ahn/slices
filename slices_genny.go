// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package slices

type OfBoolIterIf interface {
	Range(f func(i int, d bool) bool)
	Map(f func(i int, d bool) bool) OfBoolMutIf
}
type OfBoolIf interface {
	Get(int) bool
	Len() int
}
type OfBoolMutIf interface {
	OfBoolIf
	Set(int, bool) bool
}

type OfBoolAsIterIf interface {
	AsIter() OfBoolIterIf
}

type OfBoolI32If interface {
	Get(int32) bool
	Len() int32
}
type OfBoolI32MutIf interface {
	OfBoolI32If
	Set(int32, bool) bool
}

func OfBoolInto(__ OfBoolIf) []bool {
	switch d := __.(type) {
	case OfBool:
		return []bool(d)
	case *OfBoolSt:
		return []bool(d.somes)
	case nil:
		return nil
	default:
		res := make([]bool, __.Len())
		for i := 0; i < len(res); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfBool []bool

func (__ OfBool) Get(i int) bool {
	return __[i]
}
func (__ OfBool) Set(i int, d bool) bool {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfBool) Len() int {
	return len(__)
}

func (__ OfBool) AsIter() OfBoolIterIf {
	return OfBoolIter(__)
}

func OfBoolI32Into(__ OfBoolI32If) []bool {
	switch d := __.(type) {
	case OfBoolI32:
		return []bool(d)
	case *OfBoolStI32:
		return []bool(d.somes)
	case nil:
		return nil
	default:
		res := make([]bool, __.Len())
		for i := int32(0); i < int32(len(res)); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfBoolI32 []bool

func (__ OfBoolI32) Get(i int32) bool {
	return __[int(i)]
}

func (__ OfBoolI32) Set(i int32, d bool) bool {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfBoolI32) Len() int32 {
	return int32(len(__))
}

func (__ OfBoolI32) AsIter() OfBoolIterIf {
	return OfBoolIter(__)
}

type OfBoolSt struct {
	somes OfBool
}

func NewOfBoolSt(i int) *OfBoolSt {
	return &OfBoolSt{somes: OfBool(make([]bool, i))}
}

func (__ *OfBoolSt) Get(i int) bool {
	return __.somes.Get(i)
}
func (__ *OfBoolSt) Set(i int, d bool) bool {
	return __.somes.Set(i, d)
}

func (__ *OfBoolSt) Len() int {
	return __.somes.Len()
}

func (__ *OfBoolSt) AsIter() OfBoolIterIf {
	return __.somes.AsIter()
}

type OfBoolStI32 struct {
	somes OfBoolI32
}

func NewOfBoolStI32(i int32) *OfBoolSt {
	return &OfBoolSt{somes: OfBool(make([]bool, i))}
}

func (__ *OfBoolStI32) Get(i int32) bool {
	return __.somes.Get(i)
}
func (__ *OfBoolStI32) Set(i int32, d bool) bool {
	return __.somes.Set(i, d)
}

func (__ *OfBoolStI32) Len() int32 {
	return __.somes.Len()
}

func (__ *OfBoolStI32) AsIter() OfBoolIterIf {
	return __.somes.AsIter()
}

type OfBoolIter []bool

func (__ OfBoolIter) Range(f func(i int, d bool) bool) {
	for i := range __ {
		if !f(i, __[i]) {
			break
		}
	}
}
func (__ OfBoolIter) Map(f func(i int, d bool) bool) OfBoolMutIf {
	rval := make([]bool, len(__))
	for i := range __ {
		rval[i] = f(i, __[i])
	}
	return OfBool(rval)
}

type OfByteIterIf interface {
	Range(f func(i int, d byte) bool)
	Map(f func(i int, d byte) byte) OfByteMutIf
}
type OfByteIf interface {
	Get(int) byte
	Len() int
}
type OfByteMutIf interface {
	OfByteIf
	Set(int, byte) byte
}

type OfByteAsIterIf interface {
	AsIter() OfByteIterIf
}

type OfByteI32If interface {
	Get(int32) byte
	Len() int32
}
type OfByteI32MutIf interface {
	OfByteI32If
	Set(int32, byte) byte
}

func OfByteInto(__ OfByteIf) []byte {
	switch d := __.(type) {
	case OfByte:
		return []byte(d)
	case *OfByteSt:
		return []byte(d.somes)
	case nil:
		return nil
	default:
		res := make([]byte, __.Len())
		for i := 0; i < len(res); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfByte []byte

func (__ OfByte) Get(i int) byte {
	return __[i]
}
func (__ OfByte) Set(i int, d byte) byte {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfByte) Len() int {
	return len(__)
}

func (__ OfByte) AsIter() OfByteIterIf {
	return OfByteIter(__)
}

func OfByteI32Into(__ OfByteI32If) []byte {
	switch d := __.(type) {
	case OfByteI32:
		return []byte(d)
	case *OfByteStI32:
		return []byte(d.somes)
	case nil:
		return nil
	default:
		res := make([]byte, __.Len())
		for i := int32(0); i < int32(len(res)); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfByteI32 []byte

func (__ OfByteI32) Get(i int32) byte {
	return __[int(i)]
}

func (__ OfByteI32) Set(i int32, d byte) byte {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfByteI32) Len() int32 {
	return int32(len(__))
}

func (__ OfByteI32) AsIter() OfByteIterIf {
	return OfByteIter(__)
}

type OfByteSt struct {
	somes OfByte
}

func NewOfByteSt(i int) *OfByteSt {
	return &OfByteSt{somes: OfByte(make([]byte, i))}
}

func (__ *OfByteSt) Get(i int) byte {
	return __.somes.Get(i)
}
func (__ *OfByteSt) Set(i int, d byte) byte {
	return __.somes.Set(i, d)
}

func (__ *OfByteSt) Len() int {
	return __.somes.Len()
}

func (__ *OfByteSt) AsIter() OfByteIterIf {
	return __.somes.AsIter()
}

type OfByteStI32 struct {
	somes OfByteI32
}

func NewOfByteStI32(i int32) *OfByteSt {
	return &OfByteSt{somes: OfByte(make([]byte, i))}
}

func (__ *OfByteStI32) Get(i int32) byte {
	return __.somes.Get(i)
}
func (__ *OfByteStI32) Set(i int32, d byte) byte {
	return __.somes.Set(i, d)
}

func (__ *OfByteStI32) Len() int32 {
	return __.somes.Len()
}

func (__ *OfByteStI32) AsIter() OfByteIterIf {
	return __.somes.AsIter()
}

type OfByteIter []byte

func (__ OfByteIter) Range(f func(i int, d byte) bool) {
	for i := range __ {
		if !f(i, __[i]) {
			break
		}
	}
}
func (__ OfByteIter) Map(f func(i int, d byte) byte) OfByteMutIf {
	rval := make([]byte, len(__))
	for i := range __ {
		rval[i] = f(i, __[i])
	}
	return OfByte(rval)
}

type OfComplex128IterIf interface {
	Range(f func(i int, d complex128) bool)
	Map(f func(i int, d complex128) complex128) OfComplex128MutIf
}
type OfComplex128If interface {
	Get(int) complex128
	Len() int
}
type OfComplex128MutIf interface {
	OfComplex128If
	Set(int, complex128) complex128
}

type OfComplex128AsIterIf interface {
	AsIter() OfComplex128IterIf
}

type OfComplex128I32If interface {
	Get(int32) complex128
	Len() int32
}
type OfComplex128I32MutIf interface {
	OfComplex128I32If
	Set(int32, complex128) complex128
}

func OfComplex128Into(__ OfComplex128If) []complex128 {
	switch d := __.(type) {
	case OfComplex128:
		return []complex128(d)
	case *OfComplex128St:
		return []complex128(d.somes)
	case nil:
		return nil
	default:
		res := make([]complex128, __.Len())
		for i := 0; i < len(res); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfComplex128 []complex128

func (__ OfComplex128) Get(i int) complex128 {
	return __[i]
}
func (__ OfComplex128) Set(i int, d complex128) complex128 {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfComplex128) Len() int {
	return len(__)
}

func (__ OfComplex128) AsIter() OfComplex128IterIf {
	return OfComplex128Iter(__)
}

func OfComplex128I32Into(__ OfComplex128I32If) []complex128 {
	switch d := __.(type) {
	case OfComplex128I32:
		return []complex128(d)
	case *OfComplex128StI32:
		return []complex128(d.somes)
	case nil:
		return nil
	default:
		res := make([]complex128, __.Len())
		for i := int32(0); i < int32(len(res)); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfComplex128I32 []complex128

func (__ OfComplex128I32) Get(i int32) complex128 {
	return __[int(i)]
}

func (__ OfComplex128I32) Set(i int32, d complex128) complex128 {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfComplex128I32) Len() int32 {
	return int32(len(__))
}

func (__ OfComplex128I32) AsIter() OfComplex128IterIf {
	return OfComplex128Iter(__)
}

type OfComplex128St struct {
	somes OfComplex128
}

func NewOfComplex128St(i int) *OfComplex128St {
	return &OfComplex128St{somes: OfComplex128(make([]complex128, i))}
}

func (__ *OfComplex128St) Get(i int) complex128 {
	return __.somes.Get(i)
}
func (__ *OfComplex128St) Set(i int, d complex128) complex128 {
	return __.somes.Set(i, d)
}

func (__ *OfComplex128St) Len() int {
	return __.somes.Len()
}

func (__ *OfComplex128St) AsIter() OfComplex128IterIf {
	return __.somes.AsIter()
}

type OfComplex128StI32 struct {
	somes OfComplex128I32
}

func NewOfComplex128StI32(i int32) *OfComplex128St {
	return &OfComplex128St{somes: OfComplex128(make([]complex128, i))}
}

func (__ *OfComplex128StI32) Get(i int32) complex128 {
	return __.somes.Get(i)
}
func (__ *OfComplex128StI32) Set(i int32, d complex128) complex128 {
	return __.somes.Set(i, d)
}

func (__ *OfComplex128StI32) Len() int32 {
	return __.somes.Len()
}

func (__ *OfComplex128StI32) AsIter() OfComplex128IterIf {
	return __.somes.AsIter()
}

type OfComplex128Iter []complex128

func (__ OfComplex128Iter) Range(f func(i int, d complex128) bool) {
	for i := range __ {
		if !f(i, __[i]) {
			break
		}
	}
}
func (__ OfComplex128Iter) Map(f func(i int, d complex128) complex128) OfComplex128MutIf {
	rval := make([]complex128, len(__))
	for i := range __ {
		rval[i] = f(i, __[i])
	}
	return OfComplex128(rval)
}

type OfComplex64IterIf interface {
	Range(f func(i int, d complex64) bool)
	Map(f func(i int, d complex64) complex64) OfComplex64MutIf
}
type OfComplex64If interface {
	Get(int) complex64
	Len() int
}
type OfComplex64MutIf interface {
	OfComplex64If
	Set(int, complex64) complex64
}

type OfComplex64AsIterIf interface {
	AsIter() OfComplex64IterIf
}

type OfComplex64I32If interface {
	Get(int32) complex64
	Len() int32
}
type OfComplex64I32MutIf interface {
	OfComplex64I32If
	Set(int32, complex64) complex64
}

func OfComplex64Into(__ OfComplex64If) []complex64 {
	switch d := __.(type) {
	case OfComplex64:
		return []complex64(d)
	case *OfComplex64St:
		return []complex64(d.somes)
	case nil:
		return nil
	default:
		res := make([]complex64, __.Len())
		for i := 0; i < len(res); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfComplex64 []complex64

func (__ OfComplex64) Get(i int) complex64 {
	return __[i]
}
func (__ OfComplex64) Set(i int, d complex64) complex64 {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfComplex64) Len() int {
	return len(__)
}

func (__ OfComplex64) AsIter() OfComplex64IterIf {
	return OfComplex64Iter(__)
}

func OfComplex64I32Into(__ OfComplex64I32If) []complex64 {
	switch d := __.(type) {
	case OfComplex64I32:
		return []complex64(d)
	case *OfComplex64StI32:
		return []complex64(d.somes)
	case nil:
		return nil
	default:
		res := make([]complex64, __.Len())
		for i := int32(0); i < int32(len(res)); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfComplex64I32 []complex64

func (__ OfComplex64I32) Get(i int32) complex64 {
	return __[int(i)]
}

func (__ OfComplex64I32) Set(i int32, d complex64) complex64 {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfComplex64I32) Len() int32 {
	return int32(len(__))
}

func (__ OfComplex64I32) AsIter() OfComplex64IterIf {
	return OfComplex64Iter(__)
}

type OfComplex64St struct {
	somes OfComplex64
}

func NewOfComplex64St(i int) *OfComplex64St {
	return &OfComplex64St{somes: OfComplex64(make([]complex64, i))}
}

func (__ *OfComplex64St) Get(i int) complex64 {
	return __.somes.Get(i)
}
func (__ *OfComplex64St) Set(i int, d complex64) complex64 {
	return __.somes.Set(i, d)
}

func (__ *OfComplex64St) Len() int {
	return __.somes.Len()
}

func (__ *OfComplex64St) AsIter() OfComplex64IterIf {
	return __.somes.AsIter()
}

type OfComplex64StI32 struct {
	somes OfComplex64I32
}

func NewOfComplex64StI32(i int32) *OfComplex64St {
	return &OfComplex64St{somes: OfComplex64(make([]complex64, i))}
}

func (__ *OfComplex64StI32) Get(i int32) complex64 {
	return __.somes.Get(i)
}
func (__ *OfComplex64StI32) Set(i int32, d complex64) complex64 {
	return __.somes.Set(i, d)
}

func (__ *OfComplex64StI32) Len() int32 {
	return __.somes.Len()
}

func (__ *OfComplex64StI32) AsIter() OfComplex64IterIf {
	return __.somes.AsIter()
}

type OfComplex64Iter []complex64

func (__ OfComplex64Iter) Range(f func(i int, d complex64) bool) {
	for i := range __ {
		if !f(i, __[i]) {
			break
		}
	}
}
func (__ OfComplex64Iter) Map(f func(i int, d complex64) complex64) OfComplex64MutIf {
	rval := make([]complex64, len(__))
	for i := range __ {
		rval[i] = f(i, __[i])
	}
	return OfComplex64(rval)
}

type OfErrorIterIf interface {
	Range(f func(i int, d error) bool)
	Map(f func(i int, d error) error) OfErrorMutIf
}
type OfErrorIf interface {
	Get(int) error
	Len() int
}
type OfErrorMutIf interface {
	OfErrorIf
	Set(int, error) error
}

type OfErrorAsIterIf interface {
	AsIter() OfErrorIterIf
}

type OfErrorI32If interface {
	Get(int32) error
	Len() int32
}
type OfErrorI32MutIf interface {
	OfErrorI32If
	Set(int32, error) error
}

func OfErrorInto(__ OfErrorIf) []error {
	switch d := __.(type) {
	case OfError:
		return []error(d)
	case *OfErrorSt:
		return []error(d.somes)
	case nil:
		return nil
	default:
		res := make([]error, __.Len())
		for i := 0; i < len(res); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfError []error

func (__ OfError) Get(i int) error {
	return __[i]
}
func (__ OfError) Set(i int, d error) error {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfError) Len() int {
	return len(__)
}

func (__ OfError) AsIter() OfErrorIterIf {
	return OfErrorIter(__)
}

func OfErrorI32Into(__ OfErrorI32If) []error {
	switch d := __.(type) {
	case OfErrorI32:
		return []error(d)
	case *OfErrorStI32:
		return []error(d.somes)
	case nil:
		return nil
	default:
		res := make([]error, __.Len())
		for i := int32(0); i < int32(len(res)); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfErrorI32 []error

func (__ OfErrorI32) Get(i int32) error {
	return __[int(i)]
}

func (__ OfErrorI32) Set(i int32, d error) error {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfErrorI32) Len() int32 {
	return int32(len(__))
}

func (__ OfErrorI32) AsIter() OfErrorIterIf {
	return OfErrorIter(__)
}

type OfErrorSt struct {
	somes OfError
}

func NewOfErrorSt(i int) *OfErrorSt {
	return &OfErrorSt{somes: OfError(make([]error, i))}
}

func (__ *OfErrorSt) Get(i int) error {
	return __.somes.Get(i)
}
func (__ *OfErrorSt) Set(i int, d error) error {
	return __.somes.Set(i, d)
}

func (__ *OfErrorSt) Len() int {
	return __.somes.Len()
}

func (__ *OfErrorSt) AsIter() OfErrorIterIf {
	return __.somes.AsIter()
}

type OfErrorStI32 struct {
	somes OfErrorI32
}

func NewOfErrorStI32(i int32) *OfErrorSt {
	return &OfErrorSt{somes: OfError(make([]error, i))}
}

func (__ *OfErrorStI32) Get(i int32) error {
	return __.somes.Get(i)
}
func (__ *OfErrorStI32) Set(i int32, d error) error {
	return __.somes.Set(i, d)
}

func (__ *OfErrorStI32) Len() int32 {
	return __.somes.Len()
}

func (__ *OfErrorStI32) AsIter() OfErrorIterIf {
	return __.somes.AsIter()
}

type OfErrorIter []error

func (__ OfErrorIter) Range(f func(i int, d error) bool) {
	for i := range __ {
		if !f(i, __[i]) {
			break
		}
	}
}
func (__ OfErrorIter) Map(f func(i int, d error) error) OfErrorMutIf {
	rval := make([]error, len(__))
	for i := range __ {
		rval[i] = f(i, __[i])
	}
	return OfError(rval)
}

type OfFloat32IterIf interface {
	Range(f func(i int, d float32) bool)
	Map(f func(i int, d float32) float32) OfFloat32MutIf
}
type OfFloat32If interface {
	Get(int) float32
	Len() int
}
type OfFloat32MutIf interface {
	OfFloat32If
	Set(int, float32) float32
}

type OfFloat32AsIterIf interface {
	AsIter() OfFloat32IterIf
}

type OfFloat32I32If interface {
	Get(int32) float32
	Len() int32
}
type OfFloat32I32MutIf interface {
	OfFloat32I32If
	Set(int32, float32) float32
}

func OfFloat32Into(__ OfFloat32If) []float32 {
	switch d := __.(type) {
	case OfFloat32:
		return []float32(d)
	case *OfFloat32St:
		return []float32(d.somes)
	case nil:
		return nil
	default:
		res := make([]float32, __.Len())
		for i := 0; i < len(res); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfFloat32 []float32

func (__ OfFloat32) Get(i int) float32 {
	return __[i]
}
func (__ OfFloat32) Set(i int, d float32) float32 {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfFloat32) Len() int {
	return len(__)
}

func (__ OfFloat32) AsIter() OfFloat32IterIf {
	return OfFloat32Iter(__)
}

func OfFloat32I32Into(__ OfFloat32I32If) []float32 {
	switch d := __.(type) {
	case OfFloat32I32:
		return []float32(d)
	case *OfFloat32StI32:
		return []float32(d.somes)
	case nil:
		return nil
	default:
		res := make([]float32, __.Len())
		for i := int32(0); i < int32(len(res)); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfFloat32I32 []float32

func (__ OfFloat32I32) Get(i int32) float32 {
	return __[int(i)]
}

func (__ OfFloat32I32) Set(i int32, d float32) float32 {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfFloat32I32) Len() int32 {
	return int32(len(__))
}

func (__ OfFloat32I32) AsIter() OfFloat32IterIf {
	return OfFloat32Iter(__)
}

type OfFloat32St struct {
	somes OfFloat32
}

func NewOfFloat32St(i int) *OfFloat32St {
	return &OfFloat32St{somes: OfFloat32(make([]float32, i))}
}

func (__ *OfFloat32St) Get(i int) float32 {
	return __.somes.Get(i)
}
func (__ *OfFloat32St) Set(i int, d float32) float32 {
	return __.somes.Set(i, d)
}

func (__ *OfFloat32St) Len() int {
	return __.somes.Len()
}

func (__ *OfFloat32St) AsIter() OfFloat32IterIf {
	return __.somes.AsIter()
}

type OfFloat32StI32 struct {
	somes OfFloat32I32
}

func NewOfFloat32StI32(i int32) *OfFloat32St {
	return &OfFloat32St{somes: OfFloat32(make([]float32, i))}
}

func (__ *OfFloat32StI32) Get(i int32) float32 {
	return __.somes.Get(i)
}
func (__ *OfFloat32StI32) Set(i int32, d float32) float32 {
	return __.somes.Set(i, d)
}

func (__ *OfFloat32StI32) Len() int32 {
	return __.somes.Len()
}

func (__ *OfFloat32StI32) AsIter() OfFloat32IterIf {
	return __.somes.AsIter()
}

type OfFloat32Iter []float32

func (__ OfFloat32Iter) Range(f func(i int, d float32) bool) {
	for i := range __ {
		if !f(i, __[i]) {
			break
		}
	}
}
func (__ OfFloat32Iter) Map(f func(i int, d float32) float32) OfFloat32MutIf {
	rval := make([]float32, len(__))
	for i := range __ {
		rval[i] = f(i, __[i])
	}
	return OfFloat32(rval)
}

type OfFloat64IterIf interface {
	Range(f func(i int, d float64) bool)
	Map(f func(i int, d float64) float64) OfFloat64MutIf
}
type OfFloat64If interface {
	Get(int) float64
	Len() int
}
type OfFloat64MutIf interface {
	OfFloat64If
	Set(int, float64) float64
}

type OfFloat64AsIterIf interface {
	AsIter() OfFloat64IterIf
}

type OfFloat64I32If interface {
	Get(int32) float64
	Len() int32
}
type OfFloat64I32MutIf interface {
	OfFloat64I32If
	Set(int32, float64) float64
}

func OfFloat64Into(__ OfFloat64If) []float64 {
	switch d := __.(type) {
	case OfFloat64:
		return []float64(d)
	case *OfFloat64St:
		return []float64(d.somes)
	case nil:
		return nil
	default:
		res := make([]float64, __.Len())
		for i := 0; i < len(res); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfFloat64 []float64

func (__ OfFloat64) Get(i int) float64 {
	return __[i]
}
func (__ OfFloat64) Set(i int, d float64) float64 {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfFloat64) Len() int {
	return len(__)
}

func (__ OfFloat64) AsIter() OfFloat64IterIf {
	return OfFloat64Iter(__)
}

func OfFloat64I32Into(__ OfFloat64I32If) []float64 {
	switch d := __.(type) {
	case OfFloat64I32:
		return []float64(d)
	case *OfFloat64StI32:
		return []float64(d.somes)
	case nil:
		return nil
	default:
		res := make([]float64, __.Len())
		for i := int32(0); i < int32(len(res)); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfFloat64I32 []float64

func (__ OfFloat64I32) Get(i int32) float64 {
	return __[int(i)]
}

func (__ OfFloat64I32) Set(i int32, d float64) float64 {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfFloat64I32) Len() int32 {
	return int32(len(__))
}

func (__ OfFloat64I32) AsIter() OfFloat64IterIf {
	return OfFloat64Iter(__)
}

type OfFloat64St struct {
	somes OfFloat64
}

func NewOfFloat64St(i int) *OfFloat64St {
	return &OfFloat64St{somes: OfFloat64(make([]float64, i))}
}

func (__ *OfFloat64St) Get(i int) float64 {
	return __.somes.Get(i)
}
func (__ *OfFloat64St) Set(i int, d float64) float64 {
	return __.somes.Set(i, d)
}

func (__ *OfFloat64St) Len() int {
	return __.somes.Len()
}

func (__ *OfFloat64St) AsIter() OfFloat64IterIf {
	return __.somes.AsIter()
}

type OfFloat64StI32 struct {
	somes OfFloat64I32
}

func NewOfFloat64StI32(i int32) *OfFloat64St {
	return &OfFloat64St{somes: OfFloat64(make([]float64, i))}
}

func (__ *OfFloat64StI32) Get(i int32) float64 {
	return __.somes.Get(i)
}
func (__ *OfFloat64StI32) Set(i int32, d float64) float64 {
	return __.somes.Set(i, d)
}

func (__ *OfFloat64StI32) Len() int32 {
	return __.somes.Len()
}

func (__ *OfFloat64StI32) AsIter() OfFloat64IterIf {
	return __.somes.AsIter()
}

type OfFloat64Iter []float64

func (__ OfFloat64Iter) Range(f func(i int, d float64) bool) {
	for i := range __ {
		if !f(i, __[i]) {
			break
		}
	}
}
func (__ OfFloat64Iter) Map(f func(i int, d float64) float64) OfFloat64MutIf {
	rval := make([]float64, len(__))
	for i := range __ {
		rval[i] = f(i, __[i])
	}
	return OfFloat64(rval)
}

type OfIntIterIf interface {
	Range(f func(i int, d int) bool)
	Map(f func(i int, d int) int) OfIntMutIf
}
type OfIntIf interface {
	Get(int) int
	Len() int
}
type OfIntMutIf interface {
	OfIntIf
	Set(int, int) int
}

type OfIntAsIterIf interface {
	AsIter() OfIntIterIf
}

type OfIntI32If interface {
	Get(int32) int
	Len() int32
}
type OfIntI32MutIf interface {
	OfIntI32If
	Set(int32, int) int
}

func OfIntInto(__ OfIntIf) []int {
	switch d := __.(type) {
	case OfInt:
		return []int(d)
	case *OfIntSt:
		return []int(d.somes)
	case nil:
		return nil
	default:
		res := make([]int, __.Len())
		for i := 0; i < len(res); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfInt []int

func (__ OfInt) Get(i int) int {
	return __[i]
}
func (__ OfInt) Set(i int, d int) int {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfInt) Len() int {
	return len(__)
}

func (__ OfInt) AsIter() OfIntIterIf {
	return OfIntIter(__)
}

func OfIntI32Into(__ OfIntI32If) []int {
	switch d := __.(type) {
	case OfIntI32:
		return []int(d)
	case *OfIntStI32:
		return []int(d.somes)
	case nil:
		return nil
	default:
		res := make([]int, __.Len())
		for i := int32(0); i < int32(len(res)); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfIntI32 []int

func (__ OfIntI32) Get(i int32) int {
	return __[int(i)]
}

func (__ OfIntI32) Set(i int32, d int) int {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfIntI32) Len() int32 {
	return int32(len(__))
}

func (__ OfIntI32) AsIter() OfIntIterIf {
	return OfIntIter(__)
}

type OfIntSt struct {
	somes OfInt
}

func NewOfIntSt(i int) *OfIntSt {
	return &OfIntSt{somes: OfInt(make([]int, i))}
}

func (__ *OfIntSt) Get(i int) int {
	return __.somes.Get(i)
}
func (__ *OfIntSt) Set(i int, d int) int {
	return __.somes.Set(i, d)
}

func (__ *OfIntSt) Len() int {
	return __.somes.Len()
}

func (__ *OfIntSt) AsIter() OfIntIterIf {
	return __.somes.AsIter()
}

type OfIntStI32 struct {
	somes OfIntI32
}

func NewOfIntStI32(i int32) *OfIntSt {
	return &OfIntSt{somes: OfInt(make([]int, i))}
}

func (__ *OfIntStI32) Get(i int32) int {
	return __.somes.Get(i)
}
func (__ *OfIntStI32) Set(i int32, d int) int {
	return __.somes.Set(i, d)
}

func (__ *OfIntStI32) Len() int32 {
	return __.somes.Len()
}

func (__ *OfIntStI32) AsIter() OfIntIterIf {
	return __.somes.AsIter()
}

type OfIntIter []int

func (__ OfIntIter) Range(f func(i int, d int) bool) {
	for i := range __ {
		if !f(i, __[i]) {
			break
		}
	}
}
func (__ OfIntIter) Map(f func(i int, d int) int) OfIntMutIf {
	rval := make([]int, len(__))
	for i := range __ {
		rval[i] = f(i, __[i])
	}
	return OfInt(rval)
}

type OfInt16IterIf interface {
	Range(f func(i int, d int16) bool)
	Map(f func(i int, d int16) int16) OfInt16MutIf
}
type OfInt16If interface {
	Get(int) int16
	Len() int
}
type OfInt16MutIf interface {
	OfInt16If
	Set(int, int16) int16
}

type OfInt16AsIterIf interface {
	AsIter() OfInt16IterIf
}

type OfInt16I32If interface {
	Get(int32) int16
	Len() int32
}
type OfInt16I32MutIf interface {
	OfInt16I32If
	Set(int32, int16) int16
}

func OfInt16Into(__ OfInt16If) []int16 {
	switch d := __.(type) {
	case OfInt16:
		return []int16(d)
	case *OfInt16St:
		return []int16(d.somes)
	case nil:
		return nil
	default:
		res := make([]int16, __.Len())
		for i := 0; i < len(res); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfInt16 []int16

func (__ OfInt16) Get(i int) int16 {
	return __[i]
}
func (__ OfInt16) Set(i int, d int16) int16 {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfInt16) Len() int {
	return len(__)
}

func (__ OfInt16) AsIter() OfInt16IterIf {
	return OfInt16Iter(__)
}

func OfInt16I32Into(__ OfInt16I32If) []int16 {
	switch d := __.(type) {
	case OfInt16I32:
		return []int16(d)
	case *OfInt16StI32:
		return []int16(d.somes)
	case nil:
		return nil
	default:
		res := make([]int16, __.Len())
		for i := int32(0); i < int32(len(res)); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfInt16I32 []int16

func (__ OfInt16I32) Get(i int32) int16 {
	return __[int(i)]
}

func (__ OfInt16I32) Set(i int32, d int16) int16 {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfInt16I32) Len() int32 {
	return int32(len(__))
}

func (__ OfInt16I32) AsIter() OfInt16IterIf {
	return OfInt16Iter(__)
}

type OfInt16St struct {
	somes OfInt16
}

func NewOfInt16St(i int) *OfInt16St {
	return &OfInt16St{somes: OfInt16(make([]int16, i))}
}

func (__ *OfInt16St) Get(i int) int16 {
	return __.somes.Get(i)
}
func (__ *OfInt16St) Set(i int, d int16) int16 {
	return __.somes.Set(i, d)
}

func (__ *OfInt16St) Len() int {
	return __.somes.Len()
}

func (__ *OfInt16St) AsIter() OfInt16IterIf {
	return __.somes.AsIter()
}

type OfInt16StI32 struct {
	somes OfInt16I32
}

func NewOfInt16StI32(i int32) *OfInt16St {
	return &OfInt16St{somes: OfInt16(make([]int16, i))}
}

func (__ *OfInt16StI32) Get(i int32) int16 {
	return __.somes.Get(i)
}
func (__ *OfInt16StI32) Set(i int32, d int16) int16 {
	return __.somes.Set(i, d)
}

func (__ *OfInt16StI32) Len() int32 {
	return __.somes.Len()
}

func (__ *OfInt16StI32) AsIter() OfInt16IterIf {
	return __.somes.AsIter()
}

type OfInt16Iter []int16

func (__ OfInt16Iter) Range(f func(i int, d int16) bool) {
	for i := range __ {
		if !f(i, __[i]) {
			break
		}
	}
}
func (__ OfInt16Iter) Map(f func(i int, d int16) int16) OfInt16MutIf {
	rval := make([]int16, len(__))
	for i := range __ {
		rval[i] = f(i, __[i])
	}
	return OfInt16(rval)
}

type OfInt32IterIf interface {
	Range(f func(i int, d int32) bool)
	Map(f func(i int, d int32) int32) OfInt32MutIf
}
type OfInt32If interface {
	Get(int) int32
	Len() int
}
type OfInt32MutIf interface {
	OfInt32If
	Set(int, int32) int32
}

type OfInt32AsIterIf interface {
	AsIter() OfInt32IterIf
}

type OfInt32I32If interface {
	Get(int32) int32
	Len() int32
}
type OfInt32I32MutIf interface {
	OfInt32I32If
	Set(int32, int32) int32
}

func OfInt32Into(__ OfInt32If) []int32 {
	switch d := __.(type) {
	case OfInt32:
		return []int32(d)
	case *OfInt32St:
		return []int32(d.somes)
	case nil:
		return nil
	default:
		res := make([]int32, __.Len())
		for i := 0; i < len(res); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfInt32 []int32

func (__ OfInt32) Get(i int) int32 {
	return __[i]
}
func (__ OfInt32) Set(i int, d int32) int32 {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfInt32) Len() int {
	return len(__)
}

func (__ OfInt32) AsIter() OfInt32IterIf {
	return OfInt32Iter(__)
}

func OfInt32I32Into(__ OfInt32I32If) []int32 {
	switch d := __.(type) {
	case OfInt32I32:
		return []int32(d)
	case *OfInt32StI32:
		return []int32(d.somes)
	case nil:
		return nil
	default:
		res := make([]int32, __.Len())
		for i := int32(0); i < int32(len(res)); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfInt32I32 []int32

func (__ OfInt32I32) Get(i int32) int32 {
	return __[int(i)]
}

func (__ OfInt32I32) Set(i int32, d int32) int32 {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfInt32I32) Len() int32 {
	return int32(len(__))
}

func (__ OfInt32I32) AsIter() OfInt32IterIf {
	return OfInt32Iter(__)
}

type OfInt32St struct {
	somes OfInt32
}

func NewOfInt32St(i int) *OfInt32St {
	return &OfInt32St{somes: OfInt32(make([]int32, i))}
}

func (__ *OfInt32St) Get(i int) int32 {
	return __.somes.Get(i)
}
func (__ *OfInt32St) Set(i int, d int32) int32 {
	return __.somes.Set(i, d)
}

func (__ *OfInt32St) Len() int {
	return __.somes.Len()
}

func (__ *OfInt32St) AsIter() OfInt32IterIf {
	return __.somes.AsIter()
}

type OfInt32StI32 struct {
	somes OfInt32I32
}

func NewOfInt32StI32(i int32) *OfInt32St {
	return &OfInt32St{somes: OfInt32(make([]int32, i))}
}

func (__ *OfInt32StI32) Get(i int32) int32 {
	return __.somes.Get(i)
}
func (__ *OfInt32StI32) Set(i int32, d int32) int32 {
	return __.somes.Set(i, d)
}

func (__ *OfInt32StI32) Len() int32 {
	return __.somes.Len()
}

func (__ *OfInt32StI32) AsIter() OfInt32IterIf {
	return __.somes.AsIter()
}

type OfInt32Iter []int32

func (__ OfInt32Iter) Range(f func(i int, d int32) bool) {
	for i := range __ {
		if !f(i, __[i]) {
			break
		}
	}
}
func (__ OfInt32Iter) Map(f func(i int, d int32) int32) OfInt32MutIf {
	rval := make([]int32, len(__))
	for i := range __ {
		rval[i] = f(i, __[i])
	}
	return OfInt32(rval)
}

type OfInt64IterIf interface {
	Range(f func(i int, d int64) bool)
	Map(f func(i int, d int64) int64) OfInt64MutIf
}
type OfInt64If interface {
	Get(int) int64
	Len() int
}
type OfInt64MutIf interface {
	OfInt64If
	Set(int, int64) int64
}

type OfInt64AsIterIf interface {
	AsIter() OfInt64IterIf
}

type OfInt64I32If interface {
	Get(int32) int64
	Len() int32
}
type OfInt64I32MutIf interface {
	OfInt64I32If
	Set(int32, int64) int64
}

func OfInt64Into(__ OfInt64If) []int64 {
	switch d := __.(type) {
	case OfInt64:
		return []int64(d)
	case *OfInt64St:
		return []int64(d.somes)
	case nil:
		return nil
	default:
		res := make([]int64, __.Len())
		for i := 0; i < len(res); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfInt64 []int64

func (__ OfInt64) Get(i int) int64 {
	return __[i]
}
func (__ OfInt64) Set(i int, d int64) int64 {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfInt64) Len() int {
	return len(__)
}

func (__ OfInt64) AsIter() OfInt64IterIf {
	return OfInt64Iter(__)
}

func OfInt64I32Into(__ OfInt64I32If) []int64 {
	switch d := __.(type) {
	case OfInt64I32:
		return []int64(d)
	case *OfInt64StI32:
		return []int64(d.somes)
	case nil:
		return nil
	default:
		res := make([]int64, __.Len())
		for i := int32(0); i < int32(len(res)); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfInt64I32 []int64

func (__ OfInt64I32) Get(i int32) int64 {
	return __[int(i)]
}

func (__ OfInt64I32) Set(i int32, d int64) int64 {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfInt64I32) Len() int32 {
	return int32(len(__))
}

func (__ OfInt64I32) AsIter() OfInt64IterIf {
	return OfInt64Iter(__)
}

type OfInt64St struct {
	somes OfInt64
}

func NewOfInt64St(i int) *OfInt64St {
	return &OfInt64St{somes: OfInt64(make([]int64, i))}
}

func (__ *OfInt64St) Get(i int) int64 {
	return __.somes.Get(i)
}
func (__ *OfInt64St) Set(i int, d int64) int64 {
	return __.somes.Set(i, d)
}

func (__ *OfInt64St) Len() int {
	return __.somes.Len()
}

func (__ *OfInt64St) AsIter() OfInt64IterIf {
	return __.somes.AsIter()
}

type OfInt64StI32 struct {
	somes OfInt64I32
}

func NewOfInt64StI32(i int32) *OfInt64St {
	return &OfInt64St{somes: OfInt64(make([]int64, i))}
}

func (__ *OfInt64StI32) Get(i int32) int64 {
	return __.somes.Get(i)
}
func (__ *OfInt64StI32) Set(i int32, d int64) int64 {
	return __.somes.Set(i, d)
}

func (__ *OfInt64StI32) Len() int32 {
	return __.somes.Len()
}

func (__ *OfInt64StI32) AsIter() OfInt64IterIf {
	return __.somes.AsIter()
}

type OfInt64Iter []int64

func (__ OfInt64Iter) Range(f func(i int, d int64) bool) {
	for i := range __ {
		if !f(i, __[i]) {
			break
		}
	}
}
func (__ OfInt64Iter) Map(f func(i int, d int64) int64) OfInt64MutIf {
	rval := make([]int64, len(__))
	for i := range __ {
		rval[i] = f(i, __[i])
	}
	return OfInt64(rval)
}

type OfInt8IterIf interface {
	Range(f func(i int, d int8) bool)
	Map(f func(i int, d int8) int8) OfInt8MutIf
}
type OfInt8If interface {
	Get(int) int8
	Len() int
}
type OfInt8MutIf interface {
	OfInt8If
	Set(int, int8) int8
}

type OfInt8AsIterIf interface {
	AsIter() OfInt8IterIf
}

type OfInt8I32If interface {
	Get(int32) int8
	Len() int32
}
type OfInt8I32MutIf interface {
	OfInt8I32If
	Set(int32, int8) int8
}

func OfInt8Into(__ OfInt8If) []int8 {
	switch d := __.(type) {
	case OfInt8:
		return []int8(d)
	case *OfInt8St:
		return []int8(d.somes)
	case nil:
		return nil
	default:
		res := make([]int8, __.Len())
		for i := 0; i < len(res); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfInt8 []int8

func (__ OfInt8) Get(i int) int8 {
	return __[i]
}
func (__ OfInt8) Set(i int, d int8) int8 {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfInt8) Len() int {
	return len(__)
}

func (__ OfInt8) AsIter() OfInt8IterIf {
	return OfInt8Iter(__)
}

func OfInt8I32Into(__ OfInt8I32If) []int8 {
	switch d := __.(type) {
	case OfInt8I32:
		return []int8(d)
	case *OfInt8StI32:
		return []int8(d.somes)
	case nil:
		return nil
	default:
		res := make([]int8, __.Len())
		for i := int32(0); i < int32(len(res)); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfInt8I32 []int8

func (__ OfInt8I32) Get(i int32) int8 {
	return __[int(i)]
}

func (__ OfInt8I32) Set(i int32, d int8) int8 {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfInt8I32) Len() int32 {
	return int32(len(__))
}

func (__ OfInt8I32) AsIter() OfInt8IterIf {
	return OfInt8Iter(__)
}

type OfInt8St struct {
	somes OfInt8
}

func NewOfInt8St(i int) *OfInt8St {
	return &OfInt8St{somes: OfInt8(make([]int8, i))}
}

func (__ *OfInt8St) Get(i int) int8 {
	return __.somes.Get(i)
}
func (__ *OfInt8St) Set(i int, d int8) int8 {
	return __.somes.Set(i, d)
}

func (__ *OfInt8St) Len() int {
	return __.somes.Len()
}

func (__ *OfInt8St) AsIter() OfInt8IterIf {
	return __.somes.AsIter()
}

type OfInt8StI32 struct {
	somes OfInt8I32
}

func NewOfInt8StI32(i int32) *OfInt8St {
	return &OfInt8St{somes: OfInt8(make([]int8, i))}
}

func (__ *OfInt8StI32) Get(i int32) int8 {
	return __.somes.Get(i)
}
func (__ *OfInt8StI32) Set(i int32, d int8) int8 {
	return __.somes.Set(i, d)
}

func (__ *OfInt8StI32) Len() int32 {
	return __.somes.Len()
}

func (__ *OfInt8StI32) AsIter() OfInt8IterIf {
	return __.somes.AsIter()
}

type OfInt8Iter []int8

func (__ OfInt8Iter) Range(f func(i int, d int8) bool) {
	for i := range __ {
		if !f(i, __[i]) {
			break
		}
	}
}
func (__ OfInt8Iter) Map(f func(i int, d int8) int8) OfInt8MutIf {
	rval := make([]int8, len(__))
	for i := range __ {
		rval[i] = f(i, __[i])
	}
	return OfInt8(rval)
}

type OfRuneIterIf interface {
	Range(f func(i int, d rune) bool)
	Map(f func(i int, d rune) rune) OfRuneMutIf
}
type OfRuneIf interface {
	Get(int) rune
	Len() int
}
type OfRuneMutIf interface {
	OfRuneIf
	Set(int, rune) rune
}

type OfRuneAsIterIf interface {
	AsIter() OfRuneIterIf
}

type OfRuneI32If interface {
	Get(int32) rune
	Len() int32
}
type OfRuneI32MutIf interface {
	OfRuneI32If
	Set(int32, rune) rune
}

func OfRuneInto(__ OfRuneIf) []rune {
	switch d := __.(type) {
	case OfRune:
		return []rune(d)
	case *OfRuneSt:
		return []rune(d.somes)
	case nil:
		return nil
	default:
		res := make([]rune, __.Len())
		for i := 0; i < len(res); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfRune []rune

func (__ OfRune) Get(i int) rune {
	return __[i]
}
func (__ OfRune) Set(i int, d rune) rune {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfRune) Len() int {
	return len(__)
}

func (__ OfRune) AsIter() OfRuneIterIf {
	return OfRuneIter(__)
}

func OfRuneI32Into(__ OfRuneI32If) []rune {
	switch d := __.(type) {
	case OfRuneI32:
		return []rune(d)
	case *OfRuneStI32:
		return []rune(d.somes)
	case nil:
		return nil
	default:
		res := make([]rune, __.Len())
		for i := int32(0); i < int32(len(res)); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfRuneI32 []rune

func (__ OfRuneI32) Get(i int32) rune {
	return __[int(i)]
}

func (__ OfRuneI32) Set(i int32, d rune) rune {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfRuneI32) Len() int32 {
	return int32(len(__))
}

func (__ OfRuneI32) AsIter() OfRuneIterIf {
	return OfRuneIter(__)
}

type OfRuneSt struct {
	somes OfRune
}

func NewOfRuneSt(i int) *OfRuneSt {
	return &OfRuneSt{somes: OfRune(make([]rune, i))}
}

func (__ *OfRuneSt) Get(i int) rune {
	return __.somes.Get(i)
}
func (__ *OfRuneSt) Set(i int, d rune) rune {
	return __.somes.Set(i, d)
}

func (__ *OfRuneSt) Len() int {
	return __.somes.Len()
}

func (__ *OfRuneSt) AsIter() OfRuneIterIf {
	return __.somes.AsIter()
}

type OfRuneStI32 struct {
	somes OfRuneI32
}

func NewOfRuneStI32(i int32) *OfRuneSt {
	return &OfRuneSt{somes: OfRune(make([]rune, i))}
}

func (__ *OfRuneStI32) Get(i int32) rune {
	return __.somes.Get(i)
}
func (__ *OfRuneStI32) Set(i int32, d rune) rune {
	return __.somes.Set(i, d)
}

func (__ *OfRuneStI32) Len() int32 {
	return __.somes.Len()
}

func (__ *OfRuneStI32) AsIter() OfRuneIterIf {
	return __.somes.AsIter()
}

type OfRuneIter []rune

func (__ OfRuneIter) Range(f func(i int, d rune) bool) {
	for i := range __ {
		if !f(i, __[i]) {
			break
		}
	}
}
func (__ OfRuneIter) Map(f func(i int, d rune) rune) OfRuneMutIf {
	rval := make([]rune, len(__))
	for i := range __ {
		rval[i] = f(i, __[i])
	}
	return OfRune(rval)
}

type OfStringIterIf interface {
	Range(f func(i int, d string) bool)
	Map(f func(i int, d string) string) OfStringMutIf
}
type OfStringIf interface {
	Get(int) string
	Len() int
}
type OfStringMutIf interface {
	OfStringIf
	Set(int, string) string
}

type OfStringAsIterIf interface {
	AsIter() OfStringIterIf
}

type OfStringI32If interface {
	Get(int32) string
	Len() int32
}
type OfStringI32MutIf interface {
	OfStringI32If
	Set(int32, string) string
}

func OfStringInto(__ OfStringIf) []string {
	switch d := __.(type) {
	case OfString:
		return []string(d)
	case *OfStringSt:
		return []string(d.somes)
	case nil:
		return nil
	default:
		res := make([]string, __.Len())
		for i := 0; i < len(res); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfString []string

func (__ OfString) Get(i int) string {
	return __[i]
}
func (__ OfString) Set(i int, d string) string {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfString) Len() int {
	return len(__)
}

func (__ OfString) AsIter() OfStringIterIf {
	return OfStringIter(__)
}

func OfStringI32Into(__ OfStringI32If) []string {
	switch d := __.(type) {
	case OfStringI32:
		return []string(d)
	case *OfStringStI32:
		return []string(d.somes)
	case nil:
		return nil
	default:
		res := make([]string, __.Len())
		for i := int32(0); i < int32(len(res)); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfStringI32 []string

func (__ OfStringI32) Get(i int32) string {
	return __[int(i)]
}

func (__ OfStringI32) Set(i int32, d string) string {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfStringI32) Len() int32 {
	return int32(len(__))
}

func (__ OfStringI32) AsIter() OfStringIterIf {
	return OfStringIter(__)
}

type OfStringSt struct {
	somes OfString
}

func NewOfStringSt(i int) *OfStringSt {
	return &OfStringSt{somes: OfString(make([]string, i))}
}

func (__ *OfStringSt) Get(i int) string {
	return __.somes.Get(i)
}
func (__ *OfStringSt) Set(i int, d string) string {
	return __.somes.Set(i, d)
}

func (__ *OfStringSt) Len() int {
	return __.somes.Len()
}

func (__ *OfStringSt) AsIter() OfStringIterIf {
	return __.somes.AsIter()
}

type OfStringStI32 struct {
	somes OfStringI32
}

func NewOfStringStI32(i int32) *OfStringSt {
	return &OfStringSt{somes: OfString(make([]string, i))}
}

func (__ *OfStringStI32) Get(i int32) string {
	return __.somes.Get(i)
}
func (__ *OfStringStI32) Set(i int32, d string) string {
	return __.somes.Set(i, d)
}

func (__ *OfStringStI32) Len() int32 {
	return __.somes.Len()
}

func (__ *OfStringStI32) AsIter() OfStringIterIf {
	return __.somes.AsIter()
}

type OfStringIter []string

func (__ OfStringIter) Range(f func(i int, d string) bool) {
	for i := range __ {
		if !f(i, __[i]) {
			break
		}
	}
}
func (__ OfStringIter) Map(f func(i int, d string) string) OfStringMutIf {
	rval := make([]string, len(__))
	for i := range __ {
		rval[i] = f(i, __[i])
	}
	return OfString(rval)
}

type OfUintIterIf interface {
	Range(f func(i int, d uint) bool)
	Map(f func(i int, d uint) uint) OfUintMutIf
}
type OfUintIf interface {
	Get(int) uint
	Len() int
}
type OfUintMutIf interface {
	OfUintIf
	Set(int, uint) uint
}

type OfUintAsIterIf interface {
	AsIter() OfUintIterIf
}

type OfUintI32If interface {
	Get(int32) uint
	Len() int32
}
type OfUintI32MutIf interface {
	OfUintI32If
	Set(int32, uint) uint
}

func OfUintInto(__ OfUintIf) []uint {
	switch d := __.(type) {
	case OfUint:
		return []uint(d)
	case *OfUintSt:
		return []uint(d.somes)
	case nil:
		return nil
	default:
		res := make([]uint, __.Len())
		for i := 0; i < len(res); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfUint []uint

func (__ OfUint) Get(i int) uint {
	return __[i]
}
func (__ OfUint) Set(i int, d uint) uint {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfUint) Len() int {
	return len(__)
}

func (__ OfUint) AsIter() OfUintIterIf {
	return OfUintIter(__)
}

func OfUintI32Into(__ OfUintI32If) []uint {
	switch d := __.(type) {
	case OfUintI32:
		return []uint(d)
	case *OfUintStI32:
		return []uint(d.somes)
	case nil:
		return nil
	default:
		res := make([]uint, __.Len())
		for i := int32(0); i < int32(len(res)); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfUintI32 []uint

func (__ OfUintI32) Get(i int32) uint {
	return __[int(i)]
}

func (__ OfUintI32) Set(i int32, d uint) uint {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfUintI32) Len() int32 {
	return int32(len(__))
}

func (__ OfUintI32) AsIter() OfUintIterIf {
	return OfUintIter(__)
}

type OfUintSt struct {
	somes OfUint
}

func NewOfUintSt(i int) *OfUintSt {
	return &OfUintSt{somes: OfUint(make([]uint, i))}
}

func (__ *OfUintSt) Get(i int) uint {
	return __.somes.Get(i)
}
func (__ *OfUintSt) Set(i int, d uint) uint {
	return __.somes.Set(i, d)
}

func (__ *OfUintSt) Len() int {
	return __.somes.Len()
}

func (__ *OfUintSt) AsIter() OfUintIterIf {
	return __.somes.AsIter()
}

type OfUintStI32 struct {
	somes OfUintI32
}

func NewOfUintStI32(i int32) *OfUintSt {
	return &OfUintSt{somes: OfUint(make([]uint, i))}
}

func (__ *OfUintStI32) Get(i int32) uint {
	return __.somes.Get(i)
}
func (__ *OfUintStI32) Set(i int32, d uint) uint {
	return __.somes.Set(i, d)
}

func (__ *OfUintStI32) Len() int32 {
	return __.somes.Len()
}

func (__ *OfUintStI32) AsIter() OfUintIterIf {
	return __.somes.AsIter()
}

type OfUintIter []uint

func (__ OfUintIter) Range(f func(i int, d uint) bool) {
	for i := range __ {
		if !f(i, __[i]) {
			break
		}
	}
}
func (__ OfUintIter) Map(f func(i int, d uint) uint) OfUintMutIf {
	rval := make([]uint, len(__))
	for i := range __ {
		rval[i] = f(i, __[i])
	}
	return OfUint(rval)
}

type OfUint16IterIf interface {
	Range(f func(i int, d uint16) bool)
	Map(f func(i int, d uint16) uint16) OfUint16MutIf
}
type OfUint16If interface {
	Get(int) uint16
	Len() int
}
type OfUint16MutIf interface {
	OfUint16If
	Set(int, uint16) uint16
}

type OfUint16AsIterIf interface {
	AsIter() OfUint16IterIf
}

type OfUint16I32If interface {
	Get(int32) uint16
	Len() int32
}
type OfUint16I32MutIf interface {
	OfUint16I32If
	Set(int32, uint16) uint16
}

func OfUint16Into(__ OfUint16If) []uint16 {
	switch d := __.(type) {
	case OfUint16:
		return []uint16(d)
	case *OfUint16St:
		return []uint16(d.somes)
	case nil:
		return nil
	default:
		res := make([]uint16, __.Len())
		for i := 0; i < len(res); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfUint16 []uint16

func (__ OfUint16) Get(i int) uint16 {
	return __[i]
}
func (__ OfUint16) Set(i int, d uint16) uint16 {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfUint16) Len() int {
	return len(__)
}

func (__ OfUint16) AsIter() OfUint16IterIf {
	return OfUint16Iter(__)
}

func OfUint16I32Into(__ OfUint16I32If) []uint16 {
	switch d := __.(type) {
	case OfUint16I32:
		return []uint16(d)
	case *OfUint16StI32:
		return []uint16(d.somes)
	case nil:
		return nil
	default:
		res := make([]uint16, __.Len())
		for i := int32(0); i < int32(len(res)); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfUint16I32 []uint16

func (__ OfUint16I32) Get(i int32) uint16 {
	return __[int(i)]
}

func (__ OfUint16I32) Set(i int32, d uint16) uint16 {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfUint16I32) Len() int32 {
	return int32(len(__))
}

func (__ OfUint16I32) AsIter() OfUint16IterIf {
	return OfUint16Iter(__)
}

type OfUint16St struct {
	somes OfUint16
}

func NewOfUint16St(i int) *OfUint16St {
	return &OfUint16St{somes: OfUint16(make([]uint16, i))}
}

func (__ *OfUint16St) Get(i int) uint16 {
	return __.somes.Get(i)
}
func (__ *OfUint16St) Set(i int, d uint16) uint16 {
	return __.somes.Set(i, d)
}

func (__ *OfUint16St) Len() int {
	return __.somes.Len()
}

func (__ *OfUint16St) AsIter() OfUint16IterIf {
	return __.somes.AsIter()
}

type OfUint16StI32 struct {
	somes OfUint16I32
}

func NewOfUint16StI32(i int32) *OfUint16St {
	return &OfUint16St{somes: OfUint16(make([]uint16, i))}
}

func (__ *OfUint16StI32) Get(i int32) uint16 {
	return __.somes.Get(i)
}
func (__ *OfUint16StI32) Set(i int32, d uint16) uint16 {
	return __.somes.Set(i, d)
}

func (__ *OfUint16StI32) Len() int32 {
	return __.somes.Len()
}

func (__ *OfUint16StI32) AsIter() OfUint16IterIf {
	return __.somes.AsIter()
}

type OfUint16Iter []uint16

func (__ OfUint16Iter) Range(f func(i int, d uint16) bool) {
	for i := range __ {
		if !f(i, __[i]) {
			break
		}
	}
}
func (__ OfUint16Iter) Map(f func(i int, d uint16) uint16) OfUint16MutIf {
	rval := make([]uint16, len(__))
	for i := range __ {
		rval[i] = f(i, __[i])
	}
	return OfUint16(rval)
}

type OfUint32IterIf interface {
	Range(f func(i int, d uint32) bool)
	Map(f func(i int, d uint32) uint32) OfUint32MutIf
}
type OfUint32If interface {
	Get(int) uint32
	Len() int
}
type OfUint32MutIf interface {
	OfUint32If
	Set(int, uint32) uint32
}

type OfUint32AsIterIf interface {
	AsIter() OfUint32IterIf
}

type OfUint32I32If interface {
	Get(int32) uint32
	Len() int32
}
type OfUint32I32MutIf interface {
	OfUint32I32If
	Set(int32, uint32) uint32
}

func OfUint32Into(__ OfUint32If) []uint32 {
	switch d := __.(type) {
	case OfUint32:
		return []uint32(d)
	case *OfUint32St:
		return []uint32(d.somes)
	case nil:
		return nil
	default:
		res := make([]uint32, __.Len())
		for i := 0; i < len(res); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfUint32 []uint32

func (__ OfUint32) Get(i int) uint32 {
	return __[i]
}
func (__ OfUint32) Set(i int, d uint32) uint32 {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfUint32) Len() int {
	return len(__)
}

func (__ OfUint32) AsIter() OfUint32IterIf {
	return OfUint32Iter(__)
}

func OfUint32I32Into(__ OfUint32I32If) []uint32 {
	switch d := __.(type) {
	case OfUint32I32:
		return []uint32(d)
	case *OfUint32StI32:
		return []uint32(d.somes)
	case nil:
		return nil
	default:
		res := make([]uint32, __.Len())
		for i := int32(0); i < int32(len(res)); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfUint32I32 []uint32

func (__ OfUint32I32) Get(i int32) uint32 {
	return __[int(i)]
}

func (__ OfUint32I32) Set(i int32, d uint32) uint32 {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfUint32I32) Len() int32 {
	return int32(len(__))
}

func (__ OfUint32I32) AsIter() OfUint32IterIf {
	return OfUint32Iter(__)
}

type OfUint32St struct {
	somes OfUint32
}

func NewOfUint32St(i int) *OfUint32St {
	return &OfUint32St{somes: OfUint32(make([]uint32, i))}
}

func (__ *OfUint32St) Get(i int) uint32 {
	return __.somes.Get(i)
}
func (__ *OfUint32St) Set(i int, d uint32) uint32 {
	return __.somes.Set(i, d)
}

func (__ *OfUint32St) Len() int {
	return __.somes.Len()
}

func (__ *OfUint32St) AsIter() OfUint32IterIf {
	return __.somes.AsIter()
}

type OfUint32StI32 struct {
	somes OfUint32I32
}

func NewOfUint32StI32(i int32) *OfUint32St {
	return &OfUint32St{somes: OfUint32(make([]uint32, i))}
}

func (__ *OfUint32StI32) Get(i int32) uint32 {
	return __.somes.Get(i)
}
func (__ *OfUint32StI32) Set(i int32, d uint32) uint32 {
	return __.somes.Set(i, d)
}

func (__ *OfUint32StI32) Len() int32 {
	return __.somes.Len()
}

func (__ *OfUint32StI32) AsIter() OfUint32IterIf {
	return __.somes.AsIter()
}

type OfUint32Iter []uint32

func (__ OfUint32Iter) Range(f func(i int, d uint32) bool) {
	for i := range __ {
		if !f(i, __[i]) {
			break
		}
	}
}
func (__ OfUint32Iter) Map(f func(i int, d uint32) uint32) OfUint32MutIf {
	rval := make([]uint32, len(__))
	for i := range __ {
		rval[i] = f(i, __[i])
	}
	return OfUint32(rval)
}

type OfUint64IterIf interface {
	Range(f func(i int, d uint64) bool)
	Map(f func(i int, d uint64) uint64) OfUint64MutIf
}
type OfUint64If interface {
	Get(int) uint64
	Len() int
}
type OfUint64MutIf interface {
	OfUint64If
	Set(int, uint64) uint64
}

type OfUint64AsIterIf interface {
	AsIter() OfUint64IterIf
}

type OfUint64I32If interface {
	Get(int32) uint64
	Len() int32
}
type OfUint64I32MutIf interface {
	OfUint64I32If
	Set(int32, uint64) uint64
}

func OfUint64Into(__ OfUint64If) []uint64 {
	switch d := __.(type) {
	case OfUint64:
		return []uint64(d)
	case *OfUint64St:
		return []uint64(d.somes)
	case nil:
		return nil
	default:
		res := make([]uint64, __.Len())
		for i := 0; i < len(res); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfUint64 []uint64

func (__ OfUint64) Get(i int) uint64 {
	return __[i]
}
func (__ OfUint64) Set(i int, d uint64) uint64 {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfUint64) Len() int {
	return len(__)
}

func (__ OfUint64) AsIter() OfUint64IterIf {
	return OfUint64Iter(__)
}

func OfUint64I32Into(__ OfUint64I32If) []uint64 {
	switch d := __.(type) {
	case OfUint64I32:
		return []uint64(d)
	case *OfUint64StI32:
		return []uint64(d.somes)
	case nil:
		return nil
	default:
		res := make([]uint64, __.Len())
		for i := int32(0); i < int32(len(res)); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfUint64I32 []uint64

func (__ OfUint64I32) Get(i int32) uint64 {
	return __[int(i)]
}

func (__ OfUint64I32) Set(i int32, d uint64) uint64 {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfUint64I32) Len() int32 {
	return int32(len(__))
}

func (__ OfUint64I32) AsIter() OfUint64IterIf {
	return OfUint64Iter(__)
}

type OfUint64St struct {
	somes OfUint64
}

func NewOfUint64St(i int) *OfUint64St {
	return &OfUint64St{somes: OfUint64(make([]uint64, i))}
}

func (__ *OfUint64St) Get(i int) uint64 {
	return __.somes.Get(i)
}
func (__ *OfUint64St) Set(i int, d uint64) uint64 {
	return __.somes.Set(i, d)
}

func (__ *OfUint64St) Len() int {
	return __.somes.Len()
}

func (__ *OfUint64St) AsIter() OfUint64IterIf {
	return __.somes.AsIter()
}

type OfUint64StI32 struct {
	somes OfUint64I32
}

func NewOfUint64StI32(i int32) *OfUint64St {
	return &OfUint64St{somes: OfUint64(make([]uint64, i))}
}

func (__ *OfUint64StI32) Get(i int32) uint64 {
	return __.somes.Get(i)
}
func (__ *OfUint64StI32) Set(i int32, d uint64) uint64 {
	return __.somes.Set(i, d)
}

func (__ *OfUint64StI32) Len() int32 {
	return __.somes.Len()
}

func (__ *OfUint64StI32) AsIter() OfUint64IterIf {
	return __.somes.AsIter()
}

type OfUint64Iter []uint64

func (__ OfUint64Iter) Range(f func(i int, d uint64) bool) {
	for i := range __ {
		if !f(i, __[i]) {
			break
		}
	}
}
func (__ OfUint64Iter) Map(f func(i int, d uint64) uint64) OfUint64MutIf {
	rval := make([]uint64, len(__))
	for i := range __ {
		rval[i] = f(i, __[i])
	}
	return OfUint64(rval)
}

type OfUint8IterIf interface {
	Range(f func(i int, d uint8) bool)
	Map(f func(i int, d uint8) uint8) OfUint8MutIf
}
type OfUint8If interface {
	Get(int) uint8
	Len() int
}
type OfUint8MutIf interface {
	OfUint8If
	Set(int, uint8) uint8
}

type OfUint8AsIterIf interface {
	AsIter() OfUint8IterIf
}

type OfUint8I32If interface {
	Get(int32) uint8
	Len() int32
}
type OfUint8I32MutIf interface {
	OfUint8I32If
	Set(int32, uint8) uint8
}

func OfUint8Into(__ OfUint8If) []uint8 {
	switch d := __.(type) {
	case OfUint8:
		return []uint8(d)
	case *OfUint8St:
		return []uint8(d.somes)
	case nil:
		return nil
	default:
		res := make([]uint8, __.Len())
		for i := 0; i < len(res); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfUint8 []uint8

func (__ OfUint8) Get(i int) uint8 {
	return __[i]
}
func (__ OfUint8) Set(i int, d uint8) uint8 {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfUint8) Len() int {
	return len(__)
}

func (__ OfUint8) AsIter() OfUint8IterIf {
	return OfUint8Iter(__)
}

func OfUint8I32Into(__ OfUint8I32If) []uint8 {
	switch d := __.(type) {
	case OfUint8I32:
		return []uint8(d)
	case *OfUint8StI32:
		return []uint8(d.somes)
	case nil:
		return nil
	default:
		res := make([]uint8, __.Len())
		for i := int32(0); i < int32(len(res)); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfUint8I32 []uint8

func (__ OfUint8I32) Get(i int32) uint8 {
	return __[int(i)]
}

func (__ OfUint8I32) Set(i int32, d uint8) uint8 {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfUint8I32) Len() int32 {
	return int32(len(__))
}

func (__ OfUint8I32) AsIter() OfUint8IterIf {
	return OfUint8Iter(__)
}

type OfUint8St struct {
	somes OfUint8
}

func NewOfUint8St(i int) *OfUint8St {
	return &OfUint8St{somes: OfUint8(make([]uint8, i))}
}

func (__ *OfUint8St) Get(i int) uint8 {
	return __.somes.Get(i)
}
func (__ *OfUint8St) Set(i int, d uint8) uint8 {
	return __.somes.Set(i, d)
}

func (__ *OfUint8St) Len() int {
	return __.somes.Len()
}

func (__ *OfUint8St) AsIter() OfUint8IterIf {
	return __.somes.AsIter()
}

type OfUint8StI32 struct {
	somes OfUint8I32
}

func NewOfUint8StI32(i int32) *OfUint8St {
	return &OfUint8St{somes: OfUint8(make([]uint8, i))}
}

func (__ *OfUint8StI32) Get(i int32) uint8 {
	return __.somes.Get(i)
}
func (__ *OfUint8StI32) Set(i int32, d uint8) uint8 {
	return __.somes.Set(i, d)
}

func (__ *OfUint8StI32) Len() int32 {
	return __.somes.Len()
}

func (__ *OfUint8StI32) AsIter() OfUint8IterIf {
	return __.somes.AsIter()
}

type OfUint8Iter []uint8

func (__ OfUint8Iter) Range(f func(i int, d uint8) bool) {
	for i := range __ {
		if !f(i, __[i]) {
			break
		}
	}
}
func (__ OfUint8Iter) Map(f func(i int, d uint8) uint8) OfUint8MutIf {
	rval := make([]uint8, len(__))
	for i := range __ {
		rval[i] = f(i, __[i])
	}
	return OfUint8(rval)
}

type OfUintptrIterIf interface {
	Range(f func(i int, d uintptr) bool)
	Map(f func(i int, d uintptr) uintptr) OfUintptrMutIf
}
type OfUintptrIf interface {
	Get(int) uintptr
	Len() int
}
type OfUintptrMutIf interface {
	OfUintptrIf
	Set(int, uintptr) uintptr
}

type OfUintptrAsIterIf interface {
	AsIter() OfUintptrIterIf
}

type OfUintptrI32If interface {
	Get(int32) uintptr
	Len() int32
}
type OfUintptrI32MutIf interface {
	OfUintptrI32If
	Set(int32, uintptr) uintptr
}

func OfUintptrInto(__ OfUintptrIf) []uintptr {
	switch d := __.(type) {
	case OfUintptr:
		return []uintptr(d)
	case *OfUintptrSt:
		return []uintptr(d.somes)
	case nil:
		return nil
	default:
		res := make([]uintptr, __.Len())
		for i := 0; i < len(res); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfUintptr []uintptr

func (__ OfUintptr) Get(i int) uintptr {
	return __[i]
}
func (__ OfUintptr) Set(i int, d uintptr) uintptr {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfUintptr) Len() int {
	return len(__)
}

func (__ OfUintptr) AsIter() OfUintptrIterIf {
	return OfUintptrIter(__)
}

func OfUintptrI32Into(__ OfUintptrI32If) []uintptr {
	switch d := __.(type) {
	case OfUintptrI32:
		return []uintptr(d)
	case *OfUintptrStI32:
		return []uintptr(d.somes)
	case nil:
		return nil
	default:
		res := make([]uintptr, __.Len())
		for i := int32(0); i < int32(len(res)); i += 1 {
			res[i] = __.Get(i)
		}
		return res
	}
}

type OfUintptrI32 []uintptr

func (__ OfUintptrI32) Get(i int32) uintptr {
	return __[int(i)]
}

func (__ OfUintptrI32) Set(i int32, d uintptr) uintptr {
	old := __[i]
	__[i] = d
	return old
}

func (__ OfUintptrI32) Len() int32 {
	return int32(len(__))
}

func (__ OfUintptrI32) AsIter() OfUintptrIterIf {
	return OfUintptrIter(__)
}

type OfUintptrSt struct {
	somes OfUintptr
}

func NewOfUintptrSt(i int) *OfUintptrSt {
	return &OfUintptrSt{somes: OfUintptr(make([]uintptr, i))}
}

func (__ *OfUintptrSt) Get(i int) uintptr {
	return __.somes.Get(i)
}
func (__ *OfUintptrSt) Set(i int, d uintptr) uintptr {
	return __.somes.Set(i, d)
}

func (__ *OfUintptrSt) Len() int {
	return __.somes.Len()
}

func (__ *OfUintptrSt) AsIter() OfUintptrIterIf {
	return __.somes.AsIter()
}

type OfUintptrStI32 struct {
	somes OfUintptrI32
}

func NewOfUintptrStI32(i int32) *OfUintptrSt {
	return &OfUintptrSt{somes: OfUintptr(make([]uintptr, i))}
}

func (__ *OfUintptrStI32) Get(i int32) uintptr {
	return __.somes.Get(i)
}
func (__ *OfUintptrStI32) Set(i int32, d uintptr) uintptr {
	return __.somes.Set(i, d)
}

func (__ *OfUintptrStI32) Len() int32 {
	return __.somes.Len()
}

func (__ *OfUintptrStI32) AsIter() OfUintptrIterIf {
	return __.somes.AsIter()
}

type OfUintptrIter []uintptr

func (__ OfUintptrIter) Range(f func(i int, d uintptr) bool) {
	for i := range __ {
		if !f(i, __[i]) {
			break
		}
	}
}
func (__ OfUintptrIter) Map(f func(i int, d uintptr) uintptr) OfUintptrMutIf {
	rval := make([]uintptr, len(__))
	for i := range __ {
		rval[i] = f(i, __[i])
	}
	return OfUintptr(rval)
}
